
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜é˜¶ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }

        /* è§†é¢‘èƒŒæ™¯ & é®ç½© */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); z-index: 0;
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.85) 100%);
            z-index: 1; pointer-events: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }

        /* UI è®¾è®¡å‡çº§ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(10, 10, 15, 0.75);
            backdrop-filter: blur(15px);
            padding: 20px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 260px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        h2 {
            margin: 0 0 15px 0; font-size: 16px; color: #fff; letter-spacing: 2px; text-transform: uppercase;
            text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 12px;
            background: linear-gradient(90deg, #00d2ff, #ff00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .control-group { margin-bottom: 18px; }
        label { display: block; margin-bottom: 8px; font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 1px; }

        /* æŒ‰é’®ç½‘æ ¼ */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: #ccc; padding: 10px; border-radius: 6px; cursor: pointer; transition: 0.3s; font-size: 12px;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); color: white; }
        button.active {
            background: rgba(0, 210, 255, 0.2);
            border-color: #00d2ff; color: #00d2ff;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.2);
        }

        /* çŠ¶æ€æ  */
        #status {
            margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 12px; font-weight: 600; color: #aaa; text-align: center;
        }

        /* æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #hand-indicator {
            position: absolute; width: 40px; height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 5;
            display: none; transition: all 0.1s; mix-blend-mode: screen;
        }
        #hand-indicator::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: white; border-radius: 50%;
        }

        #fullscreen-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            background: none; border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 8px 12px; border-radius: 20px; cursor: pointer; font-size: 12px;
            transition: 0.3s;
        }
        #fullscreen-btn:hover { background: white; color: black; }
    </style>

    <!-- åº“æ–‡ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<video id="input-video" playsinline></video>
<div id="overlay"></div>
<div id="canvas-container"></div>
<div id="hand-indicator"></div>

<div id="ui-layer">
    <h2>âœ¨ Quantum Particles</h2>

    <div class="control-group">
        <label>Geometry Topology</label>
        <div class="btn-grid">
            <button onclick="changeShape('galaxy')" class="active">ğŸŒŒ é“¶æ²³èºæ—‹</button>
            <button onclick="changeShape('knot')">â™¾ï¸ ä¸‰å¶æ‰­ç»“</button>
            <button onclick="changeShape('sphere')">ğŸŒ é‡å­åŠ›åœº</button>
            <button onclick="changeShape('blackhole')">ğŸ•³ï¸ å¸ç§¯ç›˜</button>
            <button onclick="changeShape('heart')">â¤ï¸ æœºæ¢°ä¹‹å¿ƒ</button>
        </div>
    </div>

    <div class="control-group">
        <label>Particle Hue</label>
        <input type="range" id="hue-slider" min="0" max="360" value="200" style="width:100%">
    </div>

    <div id="status">Waiting for Camera...</div>
</div>

<button id="fullscreen-btn" onclick="toggleFullScreen()">Full Screen</button>

<script>
    // --- 1. é«˜çº§é…ç½® ---
    const PARTICLE_COUNT = 30000; // ç²’å­æ•°é‡å¤§å¹…æå‡
    let scene, camera, renderer, particles, geometry;
    let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    let targetColors = new Float32Array(PARTICLE_COUNT * 3);

    // äº¤äº’çŠ¶æ€
    let handX = 0.5, handY = 0.5;
    let isPinching = false;
    let rotationSpeedX = 0, rotationSpeedY = 0;
    let globalHue = 0.6; // åŸºç¡€è‰²ç›¸ (0-1)

    // --- 2. Three.js åˆå§‹åŒ– ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // åˆå§‹åŒ–å‡ ä½•ä½“
        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // åˆå§‹éšæœºåˆ†å¸ƒ
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5)*100;
            positions[i*3+1] = (Math.random()-0.5)*100;
            positions[i*3+2] = (Math.random()-0.5)*100;

            colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // é«˜çº§æè´¨
        const material = new THREE.PointsMaterial({
            size: 0.18,
            vertexColors: true, // å¼€å¯é¡¶ç‚¹é¢œè‰²ï¼Œå®ç°æ¸å˜
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // å‘å…‰å åŠ æ¨¡å¼
            depthWrite: false
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // åˆå§‹å½¢çŠ¶
        generateShapeData('galaxy');

        window.addEventListener('resize', onWindowResize, false);

        // è‰²ç›¸æ»‘å—
        document.getElementById('hue-slider').addEventListener('input', (e) => {
            const hue = e.target.value / 360;
            updateGlobalColor(hue);
        });

        animate();
    }

    // --- 3. å¤æ‚æ•°å­¦å½¢çŠ¶ç”Ÿæˆ (åŒ…å«è‰²å½©é€»è¾‘) ---
    function generateShapeData(type) {
        const tempPos = [];
        const tempCol = [];
        const colorVar = new THREE.Color();

        // æ›´æ–°æŒ‰é’®UI
        document.querySelectorAll('.btn-grid button').forEach(btn => btn.classList.remove('active'));
        const btnMap = {'galaxy':0, 'knot':1, 'sphere':2, 'blackhole':3, 'heart':4};
        const btns = document.querySelectorAll('.btn-grid button');
        if(btns[btnMap[type]]) btns[btnMap[type]].classList.add('active');

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;
            let r, g, b;
            const p = i / PARTICLE_COUNT; // 0.0 -> 1.0 è¿›åº¦

            if (type === 'galaxy') {
                // èºæ—‹æ˜Ÿç³»ç®—æ³•
                const arms = 5;
                const spin = i * 0.0005; // èºæ—‹å¯†åº¦
                const radius = Math.pow(Math.random(), 0.5) * 15; // åå‘ä¸­å¿ƒçš„åˆ†å¸ƒ
                const angle = radius * 0.8 + (Math.floor(Math.random() * arms) * (Math.PI * 2 / arms));

                x = Math.cos(angle) * radius;
                z = Math.sin(angle) * radius;
                y = (Math.random() - 0.5) * (20 / (radius + 1)); // ä¸­å¿ƒåšï¼Œè¾¹ç¼˜è–„

                // é¢œè‰²ï¼šä¸­å¿ƒçƒ­ï¼ˆé»„ç™½ï¼‰ï¼Œè¾¹ç¼˜å†·ï¼ˆè“ç´«ï¼‰
                const dist = Math.sqrt(x*x + z*z) / 15;
                colorVar.setHSL(0.6 + dist * 0.2, 0.8, 0.9 - dist * 0.5);
            }
            else if (type === 'knot') {
                // ä¸‰å¶æ‰­ç»“ (Torus Knot)
                const t = p * Math.PI * 2 * 3 + Math.random()*0.5; // å¢åŠ éšæœºæ€§å¡«è¡¥çº¿æ¡
                const tub = 1.5 + Math.random()*0.5; // ç®¡é“ç²—ç»†
                // (p, q) = (2, 3)
                const radius = 8 + 3 * Math.cos(3 * t);
                x = radius * Math.cos(2 * t);
                y = radius * Math.sin(2 * t);
                z = 5 * Math.sin(3 * t) + (Math.random()-0.5)*tub;

                // é¢œè‰²ï¼šæ ¹æ®è§’åº¦å˜åŒ–å½©è™¹è‰²
                colorVar.setHSL(t/10, 0.8, 0.6);
            }
            else if (type === 'sphere') {
                // é‡å­åŠ›åœº (å¸¦å™ªç‚¹çš„çƒä½“)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 10 + (Math.random() - 0.5) * 1.5; // è¡¨é¢ç²—ç³™åº¦
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);

                // å†…éƒ¨è¿˜æœ‰ä¸€å±‚æ ¸
                if (Math.random() > 0.8) {
                    x *= 0.3; y *= 0.3; z *= 0.3;
                    colorVar.setHSL(0.1, 1.0, 0.8); // äº®æ ¸
                } else {
                    colorVar.setHSL(0.6, 0.6, 0.3); // å¤–å£³
                }
            }
            else if (type === 'blackhole') {
                // å¸ç§¯ç›˜ + å–·æµ
                if (Math.random() > 0.1) {
                    // ç›˜
                    const r = 6 + Math.random() * 12;
                    const theta = Math.random() * Math.PI * 2;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    y = (Math.random()-0.5) * (r * 0.1); // è¶Šè¿œè¶Šæ•£
                    colorVar.setHSL(0.05, 0.9, 0.5 / (r/6)); // æ©™çº¢è‰²
                } else {
                    // å–·æµ
                    const h = (Math.random() - 0.5) * 30;
                    const w = 1 - Math.abs(h)/35;
                    x = (Math.random()-0.5) * w;
                    z = (Math.random()-0.5) * w;
                    y = h;
                    colorVar.setHSL(0.6, 1.0, 0.9); // äº®è“å–·æµ
                }
            }
            else if (type === 'heart') {
                // é«˜å¯†åº¦å¤æ‚çˆ±å¿ƒ
                const t = Math.random() * Math.PI * 2;
                const u = Math.random(); // å†…éƒ¨å¡«å……ç³»æ•°
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random() - 0.5) * 4;

                // ç¼©æ”¾
                const s = 0.6;
                x *= s * Math.sqrt(u); y *= s * Math.sqrt(u); z *= s;

                colorVar.setHSL(0.95, 0.8, 0.4 + u * 0.4); // æ·±çº¢åˆ°äº®ç²‰
            }

            tempPos.push(x, y, z);
            tempCol.push(colorVar.r, colorVar.g, colorVar.b);
        }

        targetPositions = new Float32Array(tempPos);
        targetColors = new Float32Array(tempCol);
    }

    function updateGlobalColor(offsetHue) {
        // è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ç€è‰²å™¨æ¨¡æ‹Ÿï¼Œå®é™…ä¸Šæˆ‘ä»¬éœ€è¦é‡æ–°ç”Ÿæˆé¢œè‰²æ•°æ®
        // ä½†ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬è¿™é‡Œåªåšç®€å•çš„è‰²ç›¸åç§»ï¼ˆåœ¨ç”Ÿæˆå½¢çŠ¶æ—¶è°ƒç”¨ï¼‰
        // è¿™é‡Œä¿ç•™æ¥å£ï¼Œå®é™…é¢œè‰²åœ¨generateShapeDataé‡Œå·²ç»å¾ˆä¸°å¯Œäº†
    }

    window.changeShape = function(type) { generateShapeData(type); }


    // --- 4. æ¸²æŸ“å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);

        const positions = particles.geometry.attributes.position.array;
        const colors = particles.geometry.attributes.color.array;
        const time = Date.now() * 0.001;

        // äº¤äº’é€»è¾‘ï¼šæ—‹è½¬
        if (isPinching) {
            // æåˆæ—¶ï¼šç›®æ ‡æ—‹è½¬è§’åº¦è·Ÿéšæ‰‹çš„ä½ç½®
            // ä½¿ç”¨ç¼“åŠ¨è®©å®ƒæ›´æœ‰â€œç£æ€§â€
            const targetRotY = (handX - 0.5) * 6;
            const targetRotX = (handY - 0.5) * 6;
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.05;
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.05;
        } else {
            // æ¾å¼€æ—¶ï¼šä¿æŒæ’å®šè‡ªè½¬
            particles.rotation.y += 0.002;
            // ç¼“æ…¢å›æ­£Xè½´
            particles.rotation.x += (0 - particles.rotation.x) * 0.02;
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;

            // ä½ç½®æ’å€¼ (Morphing)
            positions[ix] += (targetPositions[ix] - positions[ix]) * 0.05;
            positions[ix+1] += (targetPositions[ix+1] - positions[ix+1]) * 0.05;
            positions[ix+2] += (targetPositions[ix+2] - positions[ix+2]) * 0.05;

            // é¢œè‰²æ’å€¼
            colors[ix] += (targetColors[ix] - colors[ix]) * 0.03;
            colors[ix+1] += (targetColors[ix+1] - colors[ix+1]) * 0.03;
            colors[ix+2] += (targetColors[ix+2] - colors[ix+2]) * 0.03;

            // åŠ¨æ€å™ªéŸ³/å‘¼å¸æ•ˆæœ
            if (!isPinching) {
                // æ ¹æ®ä½ç½®äº§ç”Ÿæ³¢æµªï¼Œæ¨¡æ‹ŸåŠ›åœº
                const noise = Math.sin(time * 2 + positions[ix] * 0.5) * 0.02;
                positions[ix] += noise;
                positions[ix+1] += noise;
                positions[ix+2] += noise;
            }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function toggleFullScreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else if (document.exitFullscreen) document.exitFullscreen();
    }

    initThree();

    // --- 5. AI è§†è§‰é€»è¾‘ (MediaPipe) ---
    const videoEl = document.getElementById('input-video');
    const statusEl = document.getElementById('status');
    const indicator = document.getElementById('hand-indicator');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const thumb = lm[4];
            const index = lm[8];

            // è®¡ç®—ä¸­å¿ƒç‚¹ & è·ç¦»
            const cx = (thumb.x + index.x) / 2;
            const cy = (thumb.y + index.y) / 2;
            const dist = Math.sqrt(Math.pow(thumb.x-index.x,2) + Math.pow(thumb.y-index.y,2));

            // é•œåƒæ˜ å°„
            handX = 1.0 - cx;
            handY = cy;

            // æŒ‡ç¤ºå™¨è·Ÿéš
            indicator.style.display = 'block';
            indicator.style.left = (handX * 100) + '%';
            indicator.style.top = (handY * 100) + '%';

            // æåˆåˆ¤å®š
            if (dist < 0.05) {
                if (!isPinching) {
                    // åˆšè§¦å‘æåˆçš„ç¬é—´ï¼ŒæŒ‡ç¤ºå™¨å˜è‰²
                    indicator.style.borderColor = '#00ff00';
                    indicator.style.boxShadow = '0 0 20px #00ff00';
                    statusEl.innerHTML = "ğŸ”’ LOCKED - ROTATING";
                    statusEl.style.color = "#00ff00";
                }
                isPinching = true;
            } else {
                if (isPinching) {
                    indicator.style.borderColor = 'rgba(255,255,255,0.5)';
                    indicator.style.boxShadow = 'none';
                    statusEl.innerHTML = "ğŸ”“ FREE FLOW";
                    statusEl.style.color = "#aaa";
                }
                isPinching = false;
            }
        } else {
            indicator.style.display = 'none';
            isPinching = false;
            statusEl.innerHTML = "Waiting for Hand...";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoEl, {
        onFrame: async () => { await hands.send({image: videoEl}); },
        width: 1280, height: 720
    });
    cameraUtils.start();

</script>
</body>
</html>
